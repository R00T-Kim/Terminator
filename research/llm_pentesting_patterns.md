# LLM-Based Pentesting Tools: Practical Patterns for Terminator

Research into **PentestGPT** (USENIX 2024) and **try-harder** reveals practical architectural and prompting patterns applicable to Terminator's Agent Teams pipeline.

---

## 1. PentestGPT Architecture: Key Patterns

### 1.1 Three-Layer Backend Abstraction

**Pattern**: Framework-agnostic agent orchestration via abstract `AgentBackend` interface.

```python
# core/backend.py
class AgentBackend(ABC):
    async def connect() -> None
    async def disconnect() -> None
    async def query(prompt: str) -> None
    async def receive_messages() -> AsyncIterator[AgentMessage]

    @property
    def supports_resume() -> bool
    async def resume(session_id: str) -> bool
```

**Why it matters for Terminator:**
- Currently Terminator uses `claude_agent_sdk` directly via `ClaudeSDKClient`
- PentestGPT's abstraction allows swapping backends (Claude → OpenAI → Local LLM) without changing orchestration logic
- **Actionable**: Create `TerminatorBackend` ABC in `orchestrator.py`. This enables future multi-model support without rewriting `reverser`, `chain`, etc.

**Implementation**:
```python
# terminator/core/backend.py
from abc import ABC, abstractmethod
from enum import Enum

class MessageType(Enum):
    TEXT = "text"
    TOOL_START = "tool_start"
    TOOL_RESULT = "tool_result"
    RESULT = "result"
    ERROR = "error"

class TerminatorBackend(ABC):
    @abstractmethod
    async def connect(self) -> None: ...

    @abstractmethod
    async def query(self, prompt: str) -> None: ...

    @abstractmethod
    async def receive_messages(self) -> AsyncIterator[AgentMessage]: ...

    @property
    @abstractmethod
    def supports_resume(self) -> bool: ...
```

---

### 1.2 Explicit State Machine (5 States)

**Pattern**: Minimal, non-overlapping state transitions for pause/resume/stop control.

```python
class AgentState(Enum):
    IDLE = "idle"
    RUNNING = "running"
    PAUSED = "paused"
    COMPLETED = "completed"
    ERROR = "error"
```

**PentestGPT's pause/resume mechanics:**
- Safe pause points: **between messages**, not mid-response
- Resume injects instructions via `_pending_instruction`
- Stop sets `_stop_requested` flag, checked between messages

**For Terminator:**
- Current: Agent Teams run sequentially; no mid-pipeline pause
- **Actionable**: Add explicit state tracking to `Orchestrator`:
  ```python
  # terminator/orchestrator.py
  class PipelineState(Enum):
      IDLE = "idle"
      REVERSER_RUNNING = "reverser_running"
      TRIGGER_RUNNING = "trigger_running"
      CHAIN_RUNNING = "chain_running"
      VERIFIER_RUNNING = "verifier_running"
      COMPLETED = "completed"
      ERROR = "error"
      PAUSED = "paused"  # NEW: Between-agent pause point
  ```
- Enables saving/resuming at phase boundaries (e.g., pause after reverser, resume chain)
- Critical for long-running pwn challenges

---

### 1.3 Event Bus: Decoupled Agent-to-TUI Communication

**Pattern**: Observer-based pub/sub for non-blocking message passing.

```python
# core/events.py
class EventType(Enum):
    STATE_CHANGED = auto()
    MESSAGE = auto()
    TOOL = auto()
    FLAG_FOUND = auto()
    USER_COMMAND = auto()  # UI -> Agent
    USER_INPUT = auto()    # UI -> Agent (instruction injection)

class EventBus:
    def subscribe(event_type: EventType, handler: Callable) -> None
    def emit(event: Event) -> None
```

**Why it matters:**
- PentestGPT uses EventBus to decouple agent logic from TUI (Terminal UI)
- Agent doesn't know about TUI; TUI subscribes to events
- Thread-safe with locks

**For Terminator:**
- Currently: Orchestrator directly spawns agents via `Task()` tool
- **Actionable**: Adopt event-driven inter-agent communication:
  ```python
  # terminator/core/events.py (new)
  class TerminatorEventType(Enum):
      REVERSER_COMPLETE = auto()      # reverser → orchestrator
      TRIGGER_COMPLETE = auto()
      CHAIN_COMPLETE = auto()
      VERIFIER_COMPLETE = auto()
      VERIFIER_FLAG_FOUND = auto()     # Special: FLAG detected
      AGENT_ERROR = auto()
      INSTRUCTION_INJECT = auto()     # Orchestrator → agent

  # terminator/orchestrator.py
  bus = EventBus.get()

  # After reverser completes:
  bus.emit(Event(
      type=TerminatorEventType.REVERSER_COMPLETE,
      data={
          "output": reversal_map_content,
          "artifact": "/tmp/reversal_map.md"
      }
  ))

  # Chain agent listens:
  bus.subscribe(TerminatorEventType.REVERSER_COMPLETE, self._on_reverser_complete)
  ```
- Enables: (1) async monitoring of agent progress, (2) real-time reporting, (3) easy test harness

---

### 1.4 Session Persistence: File-Based State

**Pattern**: JSON-serialized session store for pause/resume across CLI invocations.

```python
# core/session.py
@dataclass
class SessionInfo:
    session_id: str
    target: str
    created_at: datetime
    status: SessionStatus  # running, paused, completed, error
    backend_session_id: str | None  # Claude Code session ID
    task: str
    user_instructions: list[str]  # Injected instructions
    flags_found: list[dict[str, str]]
    total_cost_usd: float
    model: str
    last_error: str | None

class SessionStore:
    def create(target, task, model) -> SessionInfo
    def load(session_id) -> SessionInfo
    def update_status(status) -> None
    def add_instruction(instruction) -> None
    def add_flag(flag, context) -> None
```

**For Terminator:**
- Currently: Each agent run is stateless; no session persistence
- **Actionable**: Add session state to Orchestrator:
  ```python
  # terminator/core/session.py
  @dataclass
  class CTFSession:
      session_id: str
      challenge_name: str
      created_at: datetime
      status: SessionStatus  # idle, reverser_running, reverser_done, trigger_running, etc.

      # Pipeline artifacts
      reversal_map_path: str | None
      trigger_poc_path: str | None
      chain_exploit_path: str | None
      verify_results: dict[str, Any]

      # Metadata
      user_instructions: list[str]
      flags_found: list[str]
      last_error: str | None

      def to_json(self) -> str: ...
      @classmethod
      def from_json(cls, data: str) -> "CTFSession": ...

  # Enable resume via:
  # terminator.sh --resume <session_id>
  ```
- **Key benefit**: User can pause a 6-hour reversing session, save, and resume the next day
- Store in `~/.terminator/sessions/<session_id>.json`

---

### 1.5 Regex-Based Flag Detection (Runtime)

**Pattern**: Passive regex scanning of agent output for known flag formats.

```python
FLAG_PATTERNS = [
    r"flag\{[^\}]+\}",         # flag{...}
    r"FLAG\{[^\}]+\}",         # FLAG{...}
    r"HTB\{[^\}]+\}",
    r"CTF\{[^\}]+\}",
    r"[A-Za-z0-9_]+\{[^\}]+\}", # Generic {format}
    r"\b[a-f0-9]{32}\b",        # 32-hex (HTB user/root)
]

def _detect_flags(text: str) -> list[str]:
    flags = []
    for pattern in FLAG_PATTERNS:
        for match in re.finditer(pattern, text, re.IGNORECASE):
            flags.append(match.group(0))
    return flags
```

**For Terminator:**
- Current: Only verifier explicitly looks for flags (via `remote()`)
- **Actionable**: Add flag detection to all agents:
  ```python
  # terminator/core/utils.py
  FLAG_PATTERNS = [
      r"flag\{[^\}]+\}",
      r"FLAG\{[^\}]+\}",
      r"DH\{[^\}]+\}",           # DreamHack format
      r"CYAI\{[^\}]+\}",         # CYAI Lab format
      r"[A-Za-z0-9_]+\{[^\}]+\}",
      r"\b[a-f0-9]{32}\b",       # MD5-like
  ]

  # In each agent's SendMessage:
  detected = detect_flags(output)
  if detected:
      SendMessage(
          type="message",
          recipient="team-lead",
          content=f"Flags detected: {detected}",
          summary="Flags found in output"
      )
  ```
- Emit `FLAG_FOUND` event immediately for real-time notification

---

### 1.6 Cost Tracking (Token Usage)

**Pattern**: Accumulate LLM costs per session for reporting.

```python
# In agent loop:
if isinstance(message, ResultMessage):
    cost = getattr(message, "total_cost_usd", 0)
    session.add_cost(cost)
```

**For Terminator:**
- Currently: No cost tracking
- **Actionable**: Add to AgentController:
  ```python
  # terminator/orchestrator.py
  total_cost = 0.0

  # After each agent completes:
  agent_result = await spawn_agent(...)
  cost = agent_result.get("cost_usd", 0)
  total_cost += cost
  session.add_cost(cost)

  # Final report:
  print(f"Total cost: ${total_cost:.4f}")
  print(f"Per-agent breakdown:")
  print(f"  reverser: ${reverser_cost:.4f}")
  print(f"  chain: ${chain_cost:.4f}")
  ```

---

## 2. PentestGPT's "Relentless Persistence" Prompt Strategy

### 2.1 Never-Stop Instruction

**The PentestGPT system prompt uses aggressive persistence language:**

```
CRITICAL REQUIREMENT - NEVER GIVE UP:
Your task is INCOMPLETE until you have captured at least one flag.
Do NOT stop or provide a "walkthrough so far" without flags.

- If one technique doesn't work, try alternatives immediately
- If a reverse shell fails, try different payloads, ports, encodings, protocols
- If privilege escalation is blocked, enumerate harder
- CTF challenges are ALWAYS solvable - all needed information is present
- Complexity and time spent are NOT reasons to stop - persist until flags are captured

NEVER say "given the time spent" or "given the complexity" as a reason to stop.
These are excuses, not valid conclusions.
```

**For Terminator agents:**
- Current agent prompts (reverser.md, chain.md) don't have explicit "never give up" language
- **Actionable**: Add to each agent definition:
  ```markdown
  # .claude/agents/chain.md

  ## CRITICAL RULE: Never-Stop Exploit Development

  Your task is INCOMPLETE until solve.py passes local testing 3+ times consecutively.

  - If exploit crashes: analyze core dump → adjust payload → retry
  - If offset wrong: recalculate with gdb breakpoints → validate → retry
  - If libc base unstable: implement leak first → retry
  - **Time spent and complexity are NOT valid reasons to stop**

  Ask yourself before giving up:
  1. Have I tried ALL possible offsets?
  2. Have I checked for ASLR, PIE, full RELRO?
  3. Have I verified leak with actual values from gdb?
  4. Is my ROP chain syntactically valid?

  If ANY answer is NO → Continue working. Do NOT provide partial solutions.
  ```

---

### 2.2 "Fallback Strategies" Section

**PentestGPT lists concrete alternatives when stuck:**

```
WHEN STUCK - FALLBACK STRATEGIES:

1. **Reverse Shell Not Working?**
   - Try different shells: bash, sh, python, php, perl, nc, socat
   - Try different encodings: URL, base64, hex
   - Try different ports: 80, 443, 8080, 4444, 1234
   - Try bind shell instead
   - Try staged payloads

2. **Privilege Escalation Stuck?**
   - Run full enumeration: linpeas.sh, winPEAS
   - Check SUID: find / -perm -4000 2>/dev/null
   - Check sudo: sudo -l
   - Check capabilities: getcap -r / 2>/dev/null
   - Check cron: cat /etc/crontab
```

**For Terminator agents:**
- **Actionable**: Add fallback strategies to prompts:
  ```markdown
  # .claude/agents/trigger.md

  ## Fallback Strategies (when crash not found)

  1. **Fuzzing with different patterns:**
     - Repeat pattern (AAAA...): `echo AAAA | ./binary`
     - Cyclic pattern: `pwntools cyclic(1000)`
     - Long strings: `python -c "print('A'*10000)"`

  2. **Different input methods:**
     - stdin: `echo "input" | ./binary`
     - argv: `./binary "input"`
     - file: `echo "input" > /tmp/in.txt; ./binary < /tmp/in.txt`

  3. **Edge cases:**
     - Negative numbers (blackjack style)
     - Very large numbers (> 2^32)
     - Unicode/UTF-8 (if applicable)
     - Newlines vs no-newline

  4. **If still no crash:**
     - Re-read binary strings for hints
     - Check if binary is intentionally broken
     - Verify challenge description matches binary
  ```

---

### 2.3 "Flag Patterns to Recognize" Section

**PentestGPT lists all known flag formats to search for.**

**For Terminator:**
- Update flag detection in orchestrator:
  ```python
  # terminator/core/utils.py

  FLAG_FORMATS = {
      "flag{...}": r"flag\{[^\}]+\}",
      "FLAG{...}": r"FLAG\{[^\}]+\}",
      "DH{...}": r"DH\{[^\}]+\}",
      "CYAI{...}": r"CYAI\{[^\}]+\}",
      "GoN{...}": r"GoN\{[^\}]+\}",
      "32-hex": r"\b[a-f0-9]{32}\b",
      "base64": r"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
  }
  ```

---

## 3. try-harder: Gamification & Validation Pattern

### 3.1 Exact Command Matching (OSCP Training Tool)

**try-harder is a Python training game with strict command validation:**

```python
# Host 1: Network Enumeration
cmd = "ifconfig"
user_input = input("kali@try-harder:~$ ")
if user_input.strip() == cmd:
    print("Correct! Output: inet 192.168.1.100...")
else:
    print("Try Harder")
```

**Why this is NOT good for Terminator:**
- LLMs don't follow exact command syntax (prefer high-level intent)
- But the **validation pattern** is useful for local testing

**For Terminator:**
- **Actionable**: Create a test harness that validates exploit correctness:
  ```python
  # terminator/core/validator.py

  class ExploitValidator:
      """Validate solve.py before remote execution."""

      def validate_local(self, binary_path: str, solve_path: str) -> dict:
          """Run solve.py locally 3 times, check for consistent success."""
          results = []
          for i in range(3):
              result = subprocess.run(
                  f"timeout 5 python {solve_path}",
                  cwd=os.path.dirname(binary_path),
                  capture_output=True,
                  text=True
              )
              results.append({
                  "returncode": result.returncode,
                  "stdout": result.stdout,
                  "stderr": result.stderr,
              })

          # Expect consistent success
          success_count = sum(1 for r in results if r["returncode"] == 0)
          return {
              "passed": success_count >= 2,  # At least 2/3 passes
              "consistency": success_count,
              "results": results,
          }
  ```
- Prevents verifier from attempting remote exploit on broken payloads

---

### 3.2 Hints vs Solutions

**try-harder provides **hints**, not solutions:**
- "Hint: Use a command that shows network interfaces."
- User must know it's `ifconfig`

**For Terminator:**
- **Actionable**: In prompts, use hint-based reasoning for blocked agents:
  ```markdown
  # .claude/agents/chain.md

  ## If Your Exploit Fails Locally

  DO NOT give up. Instead:
  1. Analyze the error (HINT: Check dmesg for protection mechanism errors)
  2. Adjust your approach (HINT: Is ASLR enabled? Check /proc/sys/kernel/randomize_va_space)
  3. Retry with new strategy (HINT: Try hardcoded addresses from gdb first)

  The solution is ALWAYS in the binary. You just haven't looked hard enough.
  ```

---

## 4. Concrete Implementation Roadmap for Terminator

### Phase 1: Backend Abstraction (Week 1)

1. Create `terminator/core/backend.py`:
   - Abstract `TerminatorBackend` (mimics PentestGPT)
   - Keep `ClaudeCodeBackend` implementation
   - Move `claude_agent_sdk` logic into backend

2. Create `terminator/core/events.py`:
   - Minimal EventBus (copy from PentestGPT)
   - Define `TerminatorEventType` enum

3. Update `orchestrator.py`:
   - Inject backend + events via constructor
   - Subscribe to agent completion events instead of blocking

### Phase 2: Session Persistence (Week 2)

1. Create `terminator/core/session.py`:
   - `CTFSession` dataclass (target, status, artifacts)
   - `SessionStore` with file-based persistence
   - Load/save via JSON

2. Update `orchestrator.py`:
   - Initialize session on startup
   - Save state after each agent completes
   - Support `--resume <session_id>` CLI flag

3. Update agent prompts:
   - Add session context (what's been done already)
   - Example: Chain receives "Reverser found buffer overflow at offset 32"

### Phase 3: Enhanced Prompting (Week 3)

1. Update `.claude/agents/*.md`:
   - Add "Never-Stop" section
   - Add fallback strategies per agent type
   - Add concrete next-steps when stuck

2. Update `orchestrator.py`:
   - Implement Orchestrator idle recovery:
     - Check for artifact files
     - Send "Are you still working?" message
     - Re-spawn if no response

3. Add flag detection to all agents:
   - Emit `FLAG_FOUND` event
   - Alert team lead immediately

### Phase 4: Validation Framework (Week 4)

1. Create `terminator/core/validator.py`:
   - `ExploitValidator.validate_local()` for solve.py
   - Ensure 2/3 local runs succeed before remote

2. Update verifier.md:
   - Wait for validation result
   - Fail over to chain with error details

---

## 5. Summary: Top 3 Actionable Patterns

| Pattern | Source | Benefit | Effort |
|---------|--------|---------|--------|
| **Backend Abstraction** | PentestGPT | Multi-model support future-proofing | Medium |
| **Event-Driven Communication** | PentestGPT | Real-time monitoring, decoupling | Medium |
| **Session Persistence** | PentestGPT | Pause/resume across invocations | Medium |
| **Never-Stop Prompt Language** | PentestGPT | Prevent agent cop-outs | Low |
| **Fallback Strategies** | PentestGPT | Structured alternatives when stuck | Low |
| **Local Validation** | try-harder | Prevent broken exploits reaching remote | Medium |

---

## References

- **PentestGPT**: https://github.com/GreyDGL/PentestGPT (USENIX Security 2024)
- **try-harder**: https://github.com/milosilo/try-harder (OSCP training game)

---

## Appendix: Code Snippets

### A.1 Minimal EventBus Implementation (from PentestGPT)

```python
# terminator/core/events.py
import threading
from collections.abc import Callable
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum, auto
from typing import Any, Optional

class TerminatorEventType(Enum):
    AGENT_START = auto()
    AGENT_COMPLETE = auto()
    FLAG_FOUND = auto()
    ERROR = auto()

@dataclass
class Event:
    type: TerminatorEventType
    data: dict[str, Any] = field(default_factory=dict)
    timestamp: datetime = field(default_factory=datetime.now)

class EventBus:
    _instance: Optional["EventBus"] = None
    _lock = threading.Lock()

    def __init__(self) -> None:
        self._handlers: dict[TerminatorEventType, list[Callable[[Event], None]]] = {}
        self._handler_lock = threading.Lock()

    @classmethod
    def get(cls) -> "EventBus":
        with cls._lock:
            if cls._instance is None:
                cls._instance = cls()
            return cls._instance

    def subscribe(self, event_type: TerminatorEventType, handler: Callable[[Event], None]) -> None:
        with self._handler_lock:
            if event_type not in self._handlers:
                self._handlers[event_type] = []
            if handler not in self._handlers[event_type]:
                self._handlers[event_type].append(handler)

    def emit(self, event: Event) -> None:
        with self._handler_lock:
            handlers = self._handlers.get(event.type, []).copy()
        for handler in handlers:
            try:
                handler(event)
            except Exception:
                pass  # Don't let one handler break others
```

### A.2 Backend Abstraction Interface

```python
# terminator/core/backend.py
from abc import ABC, abstractmethod
from collections.abc import AsyncIterator
from dataclasses import dataclass
from enum import Enum
from typing import Any

class MessageType(Enum):
    TEXT = "text"
    TOOL_START = "tool_start"
    TOOL_RESULT = "tool_result"
    RESULT = "result"
    ERROR = "error"

@dataclass
class AgentMessage:
    type: MessageType
    content: Any
    tool_name: str | None = None
    tool_args: dict[str, Any] | None = None
    metadata: dict[str, Any] = None

class TerminatorBackend(ABC):
    @abstractmethod
    async def connect(self) -> None:
        """Connect to the agent backend."""
        ...

    @abstractmethod
    async def disconnect(self) -> None:
        """Disconnect from the agent backend."""
        ...

    @abstractmethod
    async def query(self, prompt: str) -> None:
        """Send a query to the agent."""
        ...

    @abstractmethod
    async def receive_messages(self) -> AsyncIterator[AgentMessage]:
        """Receive messages from the agent."""
        ...

    @property
    @abstractmethod
    def session_id(self) -> str | None:
        """Get the current session ID."""
        ...

    @property
    def supports_resume(self) -> bool:
        """Whether this backend supports session resume."""
        return False

    @abstractmethod
    async def resume(self, session_id: str) -> bool:
        """Resume a previous session."""
        ...
```

---

**Document prepared**: February 15, 2026
**Research scope**: PentestGPT (86.5% benchmark success), try-harder (OSCP training)
**Target**: Terminator Agent Teams pipeline enhancements
